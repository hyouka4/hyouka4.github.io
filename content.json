{"meta":{"title":"ばらいろ","subtitle":"","description":"","author":"JYHNB","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-03-28T16:18:59.000Z","updated":"2020-03-28T16:18:59.230Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WDNMD","slug":"python记录","date":"2020-03-28T16:53:45.822Z","updated":"2020-03-28T16:55:37.931Z","comments":true,"path":"2020/03/29/python记录/","link":"","permalink":"http://yoursite.com/2020/03/29/python%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Python基础第一周导入模块例子1234import numpy as npimport matplotlib.pyplot as pltt = np.arange(0,4,0.1)plt.plot(t,t,t,t+2,t,t**2) 1.6 Python的函数、模块、包函数 *类似数学中的函数 *完成一个特定功能的一段代码 分为四类函数 内建函数（内嵌函数）可以直接使用 使用dir(builtins)查看 round函数 对浮点数进行近似取值 round(number[, ndigits]) number：必选参数，浮点数 ndigits：可选参数，保留的小数位数 12345678round(2.5)2round(2.6)3round(2.5,1)2.5round(2.56,1)2.6 四舍六入五取偶，如果加了参数，结果有变 标准库函数使用前需要import 第三方库函数使用前需要下载后import使用 用户自定义函数按照Python语法规则自己造轮子 模块 一个完整的Python文件 ​ 文件：物理上的组织方式 math.py ​ 模块： 逻辑上的组织方式 math 使用前需要import impor ModuleName 可以import多个模块 impor ModuleName1，ModuleName2 模块里导入指定的模块属性 from Module1（模块名） import ModuleElement（模块属性） 包 一个有层次的文件目录结构 定义了一个由模块和子包组成的Python应用程序执行环境 库 一组具有相关功能的模块的集合 进制转换 &gt;&gt;&gt; int(4.5) # 结果向下取整 4 &gt;&gt;&gt; int('123') # 默认为十进制 123 &gt;&gt;&gt; int('123', 8) # 将八进制数123（字符串形式）转换成十进制数83 83 &gt;&gt;&gt; oct(83) # 将十进制整数83转换成八进制形式123 '0o123' &gt;&gt;&gt; hex(83) # 将十进制整数83转换成十六进制形式53 '0x53' 1234567891011121314151617181920212223----# Python基础第二周- 程序结构：顺序 选择 重复## 2.1 条件结构### if else语句&#96;&#96;&#96;pythonprint(&quot;简某帅吗？帅请扣1，不帅请扣2&quot;)x &#x3D; int (input(&#39;&#39;))y &#x3D; 1if x &#x3D;&#x3D; y: print(&quot;你真有眼光~&quot;)else: print(&quot;お前わ、もう死んでいる！！！&quot;) 语法结构123456if expression(表达式): expr_true_suite # 表达式为ture时执行此代码块else: expr_false_suite # 表达式为false时执行此代码块 # 注意缩进 elif语句12345678910print(\"简某帅吗？帅请扣1，不帅请扣2\")x = int (input(''))y = 1z = 2if x == y: # 当条件满足时执行 print(\"你真有眼光~\")elif x == z: # 当条件不满足上一个条件时执行 print(\"お前わ、もう死んでいる！！！\")else: # 当以上条件都不满足时执行 print(\"别想逃避！！直视我！！！\") 语法结构12345678910if expression(表达式): # 条件ture时执行此代码块 expr_true_suite elif expression2(表达式2): # 上一个条件为false时执行此代码块 expr2_true_suiteelif expressionN(表达式N): # 上一个条件为false时执行此代码块 exprN_true_suite else: # 以上所有条件为false时执行此代码块 none_of_the_above_suite # 注意缩进 条件嵌套123456789101112131415print(\"简某帅吗？帅请扣1，不帅请扣2\")x = int (input(''))y = 1z = 2if x == y: print(\"你真有眼光~\")elif x == z: print(\"お前わ、もう死んでいる！！！\") C1 = int (input('再给你一次机回\\n')) #嵌套 if C1 == y: print(\"恭喜你复活啦~\") else: print(\"しね\")else: print(\"别想逃避！！直视我！！！\") 表达式写法12345c = a if a&gt;b else b # 先执行中间的if，如果返回True，就是左边，False是右边。x = int (input(''))t = 1 if x &gt; 0 else 0print(t) 2.2 range函数 2.3 循环结构while循环12345678sumA = 0 # 赋初始值J = 0while J &lt; 20: #循环条件 sumA+=J #循环代码块 J+=2print(sumA,J)&gt;&gt;&gt;90,20 语法结构12while expression: suite_to_repeat","categories":[],"tags":[]},{"title":"link","slug":"link","date":"2020-03-28T08:42:10.486Z","updated":"2020-02-26T12:01:46.000Z","comments":true,"path":"2020/03/28/link/","link":"","permalink":"http://yoursite.com/2020/03/28/link/","excerpt":"","text":"链接标签链接（hyperlink）是互联网的核心。它允许用户在页面上，从一个网址跳转到另一个网址，从而把所有资源联系在一起。 URL 是链接指向的地址。链接不仅可以指向另一个网页，也可以指向文本、图像、文件等资源。可以这样说，所有互联网上的资源，都可以通过链接访问。 &lt;a&gt;链接通过&lt;a&gt;标签表示，用户点击后，浏览器会跳转到指定的网址。下面就是一个典型的链接。 1&lt;a href=\"https://wikipedia.org/\"&gt;维基百科&lt;/a&gt; 上面代码就定义了一个超级链接。浏览器显示“维基百科”，文字下面默认会有下划线，表示这是一个链接。用户点击后，浏览器跳转到href属性指定的网址。 &lt;a&gt;标签内部不仅可以放置文字，也可以放置其他元素，比如段落、图像、多媒体等等。 123&lt;a href=\"https://www.example.com/\"&gt; &lt;img src=\"https://www.example.com/foo.jpg\"&gt;&lt;/a&gt; 上面代码中，&lt;a&gt;标签内部就是一个图像。用户点击图像，就会跳转到指定网址。 &lt;a&gt;标签有如下属性。 （1）href href属性给出链接指向的网址。它的值应该是一个 URL 或者锚点。 上文已经给出了完整 URL 的例子，下面是锚点的例子。 1&lt;a href=\"#demo\"&gt;示例&lt;/a&gt; 上面代码中，href属性的值是#加上锚点名称。点击后，浏览器会自动滚动，停在当前页面里面demo锚点所在的位置。 （2）hreflang hreflang属性给出链接指向的网址所使用的语言，纯粹是提示性的，没有实际功能。 1234&lt;a href=\"https://www.example.com\" hreflang=\"en\"&gt;示例网址&lt;/a&gt; 上面代码表明，href属性指向的网址的语言是英语。 该属性的值跟通用属性lang一样，语言代码可以参考《属性》一章的lang属性的介绍。 （3）title title属性给出链接的说明信息。鼠标悬停在链接上方时，浏览器会将这个属性的值，以提示块的形式显示出来。 1234&lt;a href=\"https://www.example.com/\" title=\"hello\"&gt;示例&lt;/a&gt;。 上面代码中，用户鼠标停留在链接上面，会出现文字提示hello。 （4）target target属性指定如何展示打开的链接。它可以是在指定的窗口打开，也可以在&lt;iframe&gt;里面打开。 12&lt;p&gt;&lt;a href=\"http://foo.com\" target=\"test\"&gt;foo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=\"http://bar.com\" target=\"test\"&gt;bar&lt;/a&gt;&lt;/p&gt; 上面代码中，两个链接都在名叫test的窗口打开。首先点击链接foo，浏览器发现没有叫做test的窗口，就新建一个窗口，起名为test，在该窗口打开foo.com。然后，用户又点击链接bar，由于已经存在test窗口，浏览器就在该窗口打开bar.com，取代里面已经打开的foo.com。 target属性的值也可以是以下四个关键字之一。 _self：当前窗口打开，这是默认值。 _blank：新窗口打开。 _parent：上层窗口打开，这通常用于从父窗口打开的子窗口，或者&lt;iframe&gt;里面的链接。如果当前窗口没有上层窗口，这个值等同于_self。 _top：顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于_self。 1234&lt;a href=\"https://www.example.com\" target=\"_blank\"&gt;示例链接&lt;/a&gt; 上面代码点击后，浏览器会新建一个窗口，在该窗口打开链接，并且新窗口没有名字。 注意，使用target属性的时候，最好跟rel=&quot;noreferrer&quot;一起使用，这样可以避免安全风险。 （5）rel rel属性说明链接与当前页面的关系。 1&lt;a href=\"help.html\" rel=\"help\"&gt;帮助&lt;/a&gt; 上面代码的rel属性，说明链接是当前页面的帮助文档。 下面是一些常见的rel属性的值。 alternate：当前文档的另一种形式，比如翻译。 author：作者链接。 bookmark：用作书签的永久地址。 external：当前文档的外部参考文档。 help：帮助链接。 license：许可证链接。 next：系列文档的下一篇。 nofollow：告诉搜索引擎忽略该链接，主要用于用户提交的内容，防止有人企图通过添加链接，提高该链接的搜索排名。 noreferrer：告诉浏览器打开链接时，不要将当前网址作为 HTTP 头信息的Referer字段发送出去，这样可以隐藏点击的来源。 noopener：告诉浏览器打开链接时，不让链接窗口通过 JavaScript 的window.opener属性引用原始窗口，这样就提高了安全性。 prev：系列文档的上一篇。 search：文档的搜索链接。 tag：文档的标签链接。 （6）referrerpolicy referrerpolicy属性用于精确设定点击链接时，浏览器发送 HTTP 头信息的Referer字段的行为。 该属性可以取下面八个值：no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url、same-origin、strict-origin、strict-origin-when-cross-origin。 其中，no-referrer表示不发送Referer字段，same-origin表示同源时才发送Referer字段，origin表示只发送源信息（协议+域名+端口）。其他几项的解释，请查阅 HTTP 文档。 （7）ping ping属性指定一个网址，用户点击的时候，会向该网址发出一个 POST 请求，通常用于跟踪用户的行为。 （8）type type属性给出链接 URL 的 MIME 类型，比如到底是网页，还是图像或文件。它也是纯粹提示性的属性，没有实际功能。 1234&lt;a href=\"smile.jpg\" type=\"image/jpeg\"&gt;示例图片&lt;/a&gt; 上面代码中，type属性提示这是一张图片。 （9）download download属性表明当前链接用于下载，而不是跳转到另一个 URL。 1&lt;a href=\"demo.txt\" download&gt;下载&lt;/a&gt; 上面代码点击后，会出现下载对话框。 注意，download属性只在链接与网址同源时，才会生效。也就是说，链接应该与网址属于同一个网站。 如果download属性设置了值，那么这个值就是下载的文件名。 1234&lt;a href=\"foo.exe\" download=\"bar.exe\"&gt;点击下载&lt;/a&gt; 上面代码中，下载文件的原始文件名是foo.exe。点击后，下载对话框提示的文件名是bar.exe。 注意，如果链接点击后，服务器的 HTTP 回应的头信息设置了Content-Disposition字段，并且该字段的值与download属性不一致，那么该字段优先，下载时将显示其设置的文件名。 download属性还有一个用途，就是有些地址不是真实网址，而是数据网址，比如data:开头的网址。这时，download属性可以为虚拟网址指定下载的文件名。 1&lt;a href=\"data:,Hello%2C%20World!\"&gt;点击&lt;/a&gt; 上面链接点击后，会打开一个虚拟网页，上面显示Hello World!。 1234&lt;a href=\"data:,Hello%2C%20World!\" download=\"hello.txt\"&gt;点击&lt;/a&gt; 上面链接点击后，下载的hello.txt文件内容就是“Hello, World!”。 邮件链接链接也可以指向一个邮件地址，使用mailto协议。用户点击后，浏览器会打开本机默认的邮件程序，让用户向指定的地址发送邮件。 1&lt;a href=\"mailto:contact@example.com\"&gt;联系我们&lt;/a&gt; 上面代码中，链接就指向邮件地址。点击后，浏览器会打开一个邮件地址，让你可以向contact@example.com发送邮件。 除了邮箱，邮件协议还允许指定其他几个邮件要素。 subject：主题 cc：抄送 bcc：密送 body：邮件内容 使用方法是将这些邮件要素，以查询字符串的方式，附加在邮箱地址后面。 123&lt;a href=\"mailto:foo@bar.com?cc=test@test.com&amp;subject=The%20subject&amp;body=The%20body\"&gt;发送邮件&lt;/a&gt; 上面代码中，邮件链接里面不仅包含了邮箱地址，还包含了cc、subject、body等邮件要素。这些要素的值需要经过 URL 转义，比如空格转成%20。 不指定邮箱也是允许的，就像下面这样。这时用户自己在邮件程序里面，填写想要发送的邮箱，通常用于邮件分享网页。 1&lt;a href=\"mailto:\"&gt;告诉朋友&lt;/a&gt; 电话链接如果是手机浏览的页面，还可以使用tel协议，创建电话链接。用户点击该链接，会唤起电话，可以进行拨号。 1&lt;a href=\"tel:13312345678\"&gt;13312345678&lt;/a&gt; 上面代码在手机中，点击链接会唤起拨号界面，可以直接拨打指定号码。 &lt;link&gt;基本用法&lt;link&gt;标签主要用于将当前网页与相关的外部资源联系起来，通常放在&lt;head&gt;元素里面。最常见的用途就是加载 CSS 样式表。 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\"&gt; 上面代码为网页加载样式表theme.css。 除了默认样式表，网页还可以加载替代样式表，即默认不生效、需要用户手动切换的样式表。 123&lt;link href=\"default.css\" rel=\"stylesheet\" title=\"Default Style\"&gt;&lt;link href=\"fancy.css\" rel=\"alternate stylesheet\" title=\"Fancy\"&gt;&lt;link href=\"basic.css\" rel=\"alternate stylesheet\" title=\"Basic\"&gt; 上面代码中，default.css是默认样式表，默认就会生效。fancy.css和basic.css是替换样式表（rel=&quot;alternate stylesheet&quot;），默认不生效。title属性在这里是必需的，用来在浏览器菜单里面列出这些样式表的名字，供用户选择，以替代默认样式表。 &lt;link&gt;还可以加载网站的 favicon 图标文件。 1&lt;link rel=\"icon\" href=\"/favicon.ico\" type=\"image/x-icon\"&gt; 手机访问时，网站通常需要提供不同分辨率的图标文件。 12&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"favicon114.png\"&gt;&lt;link rel=\"apple-touch-icon-precomposed\" sizes=\"72x72\" href=\"favicon72.png\"&gt; 上面代码指定 iPhone 设备需要的114像素和72像素的图标。 &lt;link&gt;也用于提供文档的相关链接，比如下面是给出文档的 RSS Feed 地址。 1&lt;link rel=\"alternate\" type=\"application/atom+xml\" href=\"/blog/news/atom\"&gt; rel 属性rel属性表示外部资源与当前文档之间的关系，是&lt;link&gt;标签的必需属性。它可以但不限于取以下值。 alternate：文档的另一种表现形式的链接，比如打印版。 author：文档作者的链接。 dns-prefetch：要求浏览器提前执行指定网址的 DNS 查询。 help：帮助文档的链接。 icon：加载文档的图标文件。 license：许可证链接。 next：系列文档下一篇的链接。 pingback：接收当前文档 pingback 请求的网址。 preconnect：要求浏览器提前与给定服务器，建立 HTTP 连接。 prefetch：要求浏览器提前下载并缓存指定资源，供下一个页面使用。它的优先级较低，浏览器可以不下载。 preload：要求浏览器提前下载并缓存指定资源，当前页面稍后就会用到。它的优先级较高，浏览器必须立即下载。 prerender：要求浏览器提前渲染指定链接。这样的话，用户稍后打开该链接，就会立刻显示，感觉非常快。 prev：表示当前文档是系列文档的一篇，这里给出上一篇文档的链接。 search：提供当前网页的搜索链接。 stylesheet：加载一张样式表。 下面是一些示例。 12345678910111213141516171819202122232425&lt;!-- 作者信息 --&gt;&lt;link rel=\"author\" href=\"humans.txt\"&gt;&lt;!-- 版权信息 --&gt;&lt;link rel=\"license\" href=\"copyright.html\"&gt;&lt;!-- 另一个语言的版本 --&gt;&lt;link rel=\"alternate\" href=\"https://es.example.com/\" hreflang=\"es\"&gt;&lt;!-- 联系方式 --&gt;&lt;link rel=\"me\" href=\"https://google.com/profiles/someone\" type=\"text/html\"&gt;&lt;link rel=\"me\" href=\"mailto:name@example.com\"&gt;&lt;link rel=\"me\" href=\"sms:+15035550125\"&gt;&lt;!-- 历史资料 --&gt;&lt;link rel=\"archives\" href=\"http://example.com/archives/\"&gt;&lt;!-- 目录 --&gt;&lt;link rel=\"index\" href=\"http://example.com/article/\"&gt;&lt;!-- 导航 --&gt;&lt;link rel=\"first\" href=\"http://example.com/article/\"&gt;&lt;link rel=\"last\" href=\"http://example.com/article/?page=42\"&gt;&lt;link rel=\"prev\" href=\"http://example.com/article/?page=1\"&gt;&lt;link rel=\"next\" href=\"http://example.com/article/?page=3\"&gt; 资源的预加载某些情况下，你需要浏览器预加载某些资源，也就是先把资源缓存下来，等到使用的时候，就不用再从网上下载了，立即就能使用。预处理指令可以做到这一点。 预加载主要有下面五种类型。 （1）&lt;link rel=&quot;preload&quot;&gt; &lt;link rel=&quot;preload&quot;&gt;告诉浏览器尽快下载并缓存资源（如脚本或样式表），该指令优先级较高，浏览器肯定会执行。当加载页面几秒钟后需要该资源时，它会很有用。下载后，浏览器不会对资源执行任何操作，脚本未执行，样式表未应用。它只是缓存，当其他东西需要它时，它立即可用。 1&lt;link rel=\"preload\" href=\"image.png\" as=\"image\"&gt; rel=&quot;preload&quot;除了优先级较高，还有两个优点：一是允许指定预加载资源的类型，二是允许onload事件的回调函数。下面是rel=&quot;preload&quot;配合as属性，告诉浏览器预处理资源的类型，以便正确处理。 12&lt;link rel=\"preload\" href=\"style.css\" as=\"style\"&gt;&lt;link rel=\"preload\" href=\"main.js\" as=\"script\"&gt; 上面代码要求浏览器提前下载并缓存style.css和main.js。 as属性指定加载资源的类型，它的值一般有下面几种。 “script” “style” “image” “media” “document” 如果不指定as属性，或者它的值是浏览器不认识的，那么浏览器会以较低的优先级下载这个资源。 有时还需要type属性，进一步明确 MIME 类型。 1&lt;link rel=\"preload\" href=\"sintel-short.mp4\" as=\"video\" type=\"video/mp4\"&gt; 上面代码要求浏览器提前下载视频文件，并且说明这是 MP4 编码。 下面是预下载字体文件的例子。 1&lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin&gt; 注意，所有预下载的资源，只是下载到浏览器的缓存，并没有执行。如果希望资源预下载后立刻执行，可以参考下面的写法。 1&lt;link rel=\"preload\" as=\"style\" href=\"async_style.css\" onload=\"this.rel='stylesheet'\"&gt; 上面代码中，onload指定的回调函数会在脚本下载完成后执行，立即插入页面。 （2）&lt;link rel=&quot;prefetch&quot;&gt; &lt;link rel=&quot;prefetch&quot;&gt;的使用场合是，如果后续的页面需要某个资源，并且希望预加载该资源，以便加速页面渲染。该指令不是强制性的，优先级较低，浏览器不一定会执行。这意味着，浏览器可以不下载该资源，比如连接速度很慢时。 1&lt;link rel=\"prefetch\" href=\"https://www.example.com/\"&gt; （3）&lt;link rel=&quot;preconnect&quot;&gt; &lt;link rel=&quot;preconnect&quot;&gt;要求浏览器提前与某个域名建立 TCP 连接。当你知道，很快就会请求该域名时，这会很有帮助。 1&lt;link rel=\"preconnect\" href=\"https://www.example.com/\"&gt; （4）&lt;link rel=&quot;dns-prefetch&quot;&gt; &lt;link rel=&quot;dns-prefetch&quot;&gt;要求浏览器提前执行某个域名的 DNS 解析。 1&lt;link rel=\"dns-prefetch\" href=\"//example.com/\"&gt; （5）&lt;link rel=&quot;prerender&quot;&gt; &lt;link rel=&quot;prerender&quot;&gt;要求浏览器加载某个网页，并且提前渲染它。用户点击指向该网页的链接时，就会立即呈现该页面。如果确定用户下一步会访问该页面，这会很有帮助。 1&lt;link rel=\"prerender\" href=\"http://example.com/\"&gt; media 属性media属性给出外部资源生效的媒介条件。 12&lt;link href=\"print.css\" rel=\"stylesheet\" media=\"print\"&gt;&lt;link href=\"mobile.css\" rel=\"stylesheet\" media=\"screen and (max-width: 600px)\"&gt; 上面代码中，打印时加载print.css，移动设备访问时（设备宽度小于600像素）加载mobile.css。 下面是使用media属性实现条件加载的例子。 12&lt;link rel=\"preload\" as=\"image\" href=\"map.png\" media=\"(max-width: 600px)\"&gt;&lt;link rel=\"preload\" as=\"script\" href=\"map.js\" media=\"(min-width: 601px)\"&gt; 上面代码中，如果屏幕宽度在600像素以下，则只加载第一个资源，否则就加载第二个资源。 其他属性&lt;link&gt;标签的其他属性如下。 crossorigin：加载外部资源的跨域设置。 href：外部资源的网址。 referrerpolicy：加载时Referer头信息字段的处理方法。 as：rel=&quot;preload&quot;或rel=&quot;prefetch&quot;时，设置外部资源的类型。 type：外部资源的 MIME 类型，目前仅用于rel=&quot;preload&quot;或rel=&quot;prefetch&quot;的情况。 title：加载样式表时，用来标识样式表的名称。 sizes：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。 &lt;script&gt;&lt;script&gt;用于加载脚本代码，目前主要是加载 JavaScript 代码。 123&lt;script&gt;console.log('hello world');&lt;/script&gt; 上面代码嵌入网页，会立即执行。 &lt;script&gt;也可以加载外部脚本，src属性给出外部脚本的地址。 1&lt;script src=\"javascript.js\"&gt;&lt;/script&gt; 上面代码会加载javascript.js脚本文件，并执行。 type属性给出脚本的类型，默认是 JavaScript 代码，所以可省略。完整的写法其实是下面这样。 1&lt;script type=\"text/javascript\" src=\"javascript.js\"&gt;&lt;/script&gt; type属性也可以设成module，表示这是一个 ES6 模块，不是传统脚本。 1&lt;script type=\"module\" src=\"main.js\"&gt;&lt;/script&gt; 对于那些不支持 ES6 模块的浏览器，可以设置nomodule属性。支持 ES6 模块的浏览器，会不加载指定的脚本。这个属性通常与type=&quot;module&quot;配合使用，作为老式浏览器的回退方案。 12&lt;script type=\"module\" src=\"main.js\"&gt;&lt;/script&gt;&lt;script nomodule src=\"fallback.js\"&gt;&lt;/script&gt; &lt;script&gt;还有下面一些其他属性，大部分跟 JavaScript 语言有关，可以参考相关的 JavaScript 教程。 async：该属性指定 JavaScript 代码为异步执行，不是造成阻塞效果，JavaScript 代码默认是同步执行。 defer：该属性指定 JavaScript 代码不是立即执行，而是页面解析完成后执行。 crossorigin：如果采用这个属性，就会采用跨域的方式加载外部脚本，即 HTTP 请求的头信息会加上origin字段。 integrity：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。 nonce：一个密码随机数，由服务器在 HTTP 头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。 referrerpolicy：HTTP 请求的Referer字段的处理方法。 &lt;noscript&gt;&lt;noscript&gt;标签用于浏览器不支持或关闭 JavaScript 时，所要显示的内容。用户关闭 JavaScript 可能是为了节省带宽，以延长手机电池寿命，或者为了防止追踪，保护隐私。 123&lt;noscript&gt; 您的浏览器不能执行 JavaScript 语言，页面无法正常显示。&lt;/noscript&gt; 上面这段代码，只有浏览器不能执行 JavaScript 代码时才会显示，否则就不会显示。 参考链接 A free guide to &lt;head&gt; elements","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-28T08:22:56.513Z","updated":"2020-03-28T08:22:56.513Z","comments":true,"path":"2020/03/28/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}